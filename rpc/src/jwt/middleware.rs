use poem::http::header::AUTHORIZATION;
use poem::{Endpoint, Middleware, Request, Result};

use super::claims::JwtSecret;

pub struct JwtMiddleware(pub JwtSecret);

impl<E: Endpoint> Middleware<E> for JwtMiddleware {
    type Output = JwtMiddlewareImpl<E>;
    fn transform(&self, ep: E) -> Self::Output {
        JwtMiddlewareImpl { jwt: self.0, ep }
    }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct JwtMiddlewareImpl<E> {
    jwt: JwtSecret,
    ep: E,
}

impl<E: Endpoint> Endpoint for JwtMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, req: Request) -> Result<Self::Output> {
        if let Some(value) = req
            .headers()
            .get(AUTHORIZATION)
            .and_then(|value| value.to_str().ok())
            .filter(|value| value.starts_with("Bearer "))
            .map(|value| &value[7..])
        {
            let _claims = self.jwt.decode(value)?;
            // TODO: check that claims are correct
            self.ep.call(req).await
        } else {
            Err(poem_grants::error::AccessError::UnauthorizedRequest.into())
        }
    }
}
